// FSM
always @*
   begin 
   // defaults
   
   bomb_exp_state_next = bomb_exp_state_reg;
   bomb_active_next    = bomb_active_reg;
   exp_active_next     = exp_active_reg;
   bomb_x_next         = bomb_x_reg;
   bomb_y_next         = bomb_y_reg;
   exp_block_addr_next = exp_block_addr_reg;
   block_we_next       = block_we_reg;
   post_exp_active     = 0;
   
    
   case(bomb_exp_state_reg)
   
    no_bomb: begin
    if(A && !gameover) begin
       bomb_active_next <= 1;
       bomb_x_next = x_bomb_a[9:4];
       bomb_y_next = y_bomb_a[9:4];
       bomb_exp_state_next <= bomb_exp_state_reg + 1;
    end 
    end
    
    bomb: begin
    if(bomb_counter_reg == BOMB_COUNTER_MAX) begin
    bomb_active_next <= 0;
    exp_active_next <= 1;
    block_we_next <= 1;
    bomb_exp_state_next <= bomb_exp_state_reg +1;
    end
    end
    
    exp_1: begin
    exp_block_addr_next <= bomb_x_reg - 1 + bomb_y_reg*33;
    bomb_exp_state_next <= bomb_exp_state_reg +1;
    end
    
    exp_2: begin
    exp_block_addr_next <= bomb_x_reg + 1 + bomb_y_reg*33;
    bomb_exp_state_next <= bomb_exp_state_reg +1;
    end
    
    exp_3: begin
    exp_block_addr_next <= bomb_x_reg + (bomb_y_reg - 1)*33;
    bomb_exp_state_next <= bomb_exp_state_reg +1;
    end
    
    exp_4: begin
    exp_block_addr_next <= bomb_x_reg + (bomb_y_reg + 1)*33;
    bomb_exp_state_next <= bomb_exp_state_reg +1;
    end
    
    post_exp: begin
    post_exp_active <= 1;
    if(exp_counter_reg == EXP_COUNTER_MAX) begin
       exp_active_next <= 0;
       bomb_exp_state_next <= 0;
    end
    end
    
    default: begin
    bomb_exp_state_next <= bomb_exp_state_reg +1;
    end
    // insert FSM 
      
   endcase
       
end        // END FSM next-state logic 